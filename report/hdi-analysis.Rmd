---
title: "HDI analyses"
author: "Andrew Edwards"
output: pdf_document
fontsize: 12pt
date: "Last compiled on `r format(Sys.time(), '%d %B, %Y')`"
---

```{r, echo = FALSE, eval = FALSE}
rmarkdown::render("hdi-analysis.Rmd")
```

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "",
  fig.width = 10,
  fig.height = 8
)
```

```{r, packages}
library(dplyr)
# library(pacea)
load_all()
```

First copying over what I had in the sandbox, then deleting down what isn't
needed. Had originally (in 2022) tried making histograms as they avoid smoothing, but fiddly and best
not to, as don't demonstrate the issue as clearly as I'd thought, because of the
first bins in the tails not being the same height (because they are bins); see
hdi-notes.pdf.

From ?hdi:
Kruschke, J. K. 2011. _Doing Bayesian data analysis: a tutorial
     with R and BUGS._ Elsevier, Amsterdam, section 3.3.5.


## Recruitment

```{r rec}
par(mfrow = c(2,1))
plot_recruitment_density(year = 2021, type = "equal")
plot_recruitment_density(year = 2021, type = "hdi")

```

Doesn't quite look right.

- fix the right-hand side
- shade areas to show the problem


Dig into analyses to understand better. From `?HDInterval::hdi`:

`None of the above use interpolation: the values returned
correspond to specific values in the data object, and will be
conservative (ie, too wide rather than too narrow). Results thus
depend on the random draws, and will be unstable if few values are
provided. For a 95% HDI, 10,000 independent draws are recommended;
a smaller number will be adequate for a 80% HDI, many more for a
99% HDI.`

So there is no interpolation, values should be specific values in the data
object, which explains why the y values look different above. So, let's confirm that:

```{r rec2}
# plot_recruitment() calls create_intervals() which acts on all mcmc results to
# get intervals for each year, and uses HDInterval::hdi(). So do one example
year <- 2021
one_year_mcmc <- pull(hake_recruitment_mcmc,
                      as.character(year))    # Full 8000 MCMC samples for that year
# TODO save that as an object

one_year_mcmc_sort <- sort(one_year_mcmc)    # Useful later

head(one_year_mcmc_sort)
tail(one_year_mcmc_sort)
summary(one_year_mcmc_sort)


hdi_res <- HDInterval::hdi(one_year_mcmc)
hdi_res
sum(one_year_mcmc == hdi_res["lower"])   # = 1, so is an exact value.
sum(one_year_mcmc == hdi_res["upper"])   # = 1, as expected
```

So presumably `hdi()` just shifts the interval along to get to the shortest 95%
value. I'd thought (before carefully reading the help quoted above) that it does
do some interpolation. See exactly what it does. Best to look at
https://github.com/mikemeredith/HDInterval . Basically, all methods (based on
class of object) use `hdiVector()`, which is not exported, but is (from GitHub):

```{r hdiVector, eval=FALSE}
# This is the function to deal with a 'raw' vector
# Not exported.

# Returns NAs for non-numeric input or all-NA input

hdiVector <- function(object, credMass=0.95, ...) {
  result <- c(NA_real_, NA_real_)
  if(is.numeric(object)) {
    attributes(object) <- NULL
    x <- sort.int(object, method='quick')  # removes NA/NaN, but not Inf
    n <- length(x)
    if(n > 0) {
      # exclude <- ceiling(n * (1 - credMass)) # Not always the same as...
      exclude <- n - floor(n * credMass)       # Number of values to exclude
      low.poss <- x[1:exclude]             # Possible lower limits...
      upp.poss <- x[(n - exclude + 1):n]   # ... and corresponding upper limits
      best <- which.min(upp.poss - low.poss)      # Combination giving the narrowest interval
      if(length(best)) {
        result <- c(low.poss[best], upp.poss[best])
      } else {
        tmp <- range(x)
        if(length(tmp) == 2)
          result <- tmp
      }
    }
  }
  names(result) <- c("lower", "upper")
  return(result)
}
```

So, because the calculated interval is actually wider than the 'true' interval,
the interpolation in my figure should be tweaked. Doing that now in
`plot_recruitment_density()`, with some thinking here:

```{r calcs}
range(diff(res$dens$x))      # x values are equally spaced
res$i_low
res$low
res$dens$x[(res$i_low - 1):(res$i_low + 1)]   # The recruitment values around the
                                              # HDI low
res$y_low
res$dens$y[(res$i_low - 1):(res$i_low + 1)]   # The density values around the
                                              # HDI low
# Can see both are in interval what corresponds to [i_low, i_low+1), so original interpolation is
# correct in plot_recruitment_density().

# Do the same for high:
res$i_high
res$high
res$dens$x[(res$i_high - 1):(res$i_high + 1)]   # The recruitment values around the
                                                # HDI high
res$y_high
res$dens$y[(res$i_high - 1):(res$i_high + 1)]   # The density values around the
                                                # HDI high

# So again, both are indeed correctly in what corresponds to [i_high,
# i_high+1).
```

So the trouble is actually the HDI calculation NOT doing any interpolation, only
using the given values. But in the tail these are spread out. ALSO, `density()`
does equally spaced values, but the tail of the data is so spread out:
```{r tail}
tail(one_year_mcmc_sort)
```
so lots of values are wasted in the big gap at the end.
```{r rug}
plot(res$dens)
rug(one_year_mcmc_sort)

# abline(v = rr$dens$x[rr$ints$i_high_hdi])
```

HERE - roughly what was doing, need to tidy things up.
```{r fripm}
rr <- calc_density(one_year_mcmc)
plot_density()
abline(v = rr$dens$x[rr$ints$i_high_hdi])
abline(v = rr$dens$x[rr$ints$i_high_hdi-1], col="green")
abline(v = rr$dens$x[rr$ints$i_low_hdi-1], col="green")
abline(v = rr$dens$x[rr$ints$i_low_hdi], col="black")
```

How about doing the HDI on the density version (which is kind of what I assumed
it was doing anyway). Ideally like to figure out the problem with doing it on
the MCMC values, but that could be an option. Need to draw some figures.
Don't think I need `plot_recruitment_density()` in it's current state, as
simplified to `plot_density()`.

See if Marie knows more about `?density` kernels etc.
