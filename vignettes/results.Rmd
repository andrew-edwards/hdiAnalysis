---
title: "Results"
author: "Andrew Edwards"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Results}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
date: "Last rendered on `r format(Sys.time(), '%d %B, %Y')`"
---

<!-- To build either run
rmarkdown::render("results.Rmd")
 or click the knit button in RStudio -->


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 6
)
```

TODO If stick with `density = FALSE` then change `create_intervals()` default to
that, and remove the specific options here, and redo any other required
vignettes (likely just save them and their pdf's for reference; might not need
them all anyway).

This vignette reproduces the main results in the manuscript, and can easily be
used as a template for users to apply to their own data or model outputs. The longer
`results-long` vignette gives more details of outputs and further examples of
plotting features.

Set up:
```{r setup}
load_all()      # TODO change to library(hdiAnalysis) when done
library(dplyr)
library(coda)            # Needed to test alternative code TODO maybe not needed
```

## Analyse a single vector of values

Our first 'data' set is the hake Markov chain Monte Carlo (MCMC) recruitment
values for 2021, which is saved as a data object in the package as
`rec_2021`. It is a simple vector of the 8,000 MCMC values, and we will use it
to create Figure 1 and associated numbers. To run this code on your own
data you just need to have your values in a vector, and replace `rec_2021` with the
name of your vector.

```{r vector}
vec <- rec_2021
summary(vec)
length(vec)
```

We use the `create_intervals` function to do the main calculations. We call the
results here `res_vec` for results on a vector, so that the subsequent code will not need changing by users for their own analyses:

```{r vectorres}
res_vec <- create_intervals(vec,
                            density = FALSE)
res_vec
```
As seen above, `res_vec` is a list, with first element `$intervals` containing
results such as the median, lower and upper bounds for the equal-tailed interval
(ETI) and for the highest density interval (HDI) , widths of the
ETI and HDI, and more. See `?create_intervals` for full details of what is returned. TODO
check that. We will show a table of the key values after plotting the
figures.

The second element of `res_vec` is `$density` (seen above), which is a
kernel density estimate of the distribution represented by the samples in
`vec`. It is useful for plotting and calculating approximate intervals.

The HDI is calculated using the `HDInterval::hdi()` function, and we explore other
choices in the `results-long` vignette. TODO

## Plot the distribution showing the ETI and HDI -- Figure 1

Plotting the resulting density function and intervals is simply done using our
custom plotting functions, with options for automatically adding intervals and
lines. The ETI plot (Figure 1A) is:
```{r plot}
plot(res_vec,
     type = "eti",
     xlim = c(0, 40),
     ylim = c(0, 0.11),
     interval_arrows = TRUE,
     xlab = "Recruitment (billions of age-0 fish)",
     arrowhead_gap = 0.1)
```
and the HDI plot (Figure 1B) is
```{r plot2}
plot(res_vec,
     type = "hdi",
     xlim = c(0, 40),
     ylim = c(0, 0.11),
     interval_arrows = TRUE,
     xlab = "Recruitment (billions of age-0 fish)",
     arrowhead_gap = 0.1)
```
The `plot()` command automatically uses our custom plotting function
`plot.intervals_density()`, because the `res_vec` object has our class
`intervals_density`. See `?plot.intervals_density()` for details and full
options. Our complete Figure 1
is reproduced with the command `figure_1()`, which can be adapted by users if
desired for their own data, or just adapt the above code as necessary
(e.g., change the limits and labels).

The main values of interest are simplified in our customised `summary_table()` function:
```{r tab, results = "asis"}
summary_table(res_vec)
```

The full results are
```{r fullres}
res_vec$intervals %>% a()       # a() is our shorthand function for as.data.frame()
```
for which definitions are given in the help file `?create_intervals`.


## MCMC samples for multiple years -- recruitment for Figure 2A

We now present calculations for multiple data sets, in our case multiple years
of MCMC samples of hake recruitment.

The values are saved in the package as the tibble `hake_recruitment_mcmc`, with each
column corresponding to a year
(with the first column representing the Virgin unfished equilibrium biomass) and
each of the 8,000 rows representing an MCMC sample:
```{r hake_mcmc}
hake_recruitment_mcmc
```

To create ETIs and HDIs for estimates of recruitment for each year, we can simply use
`create_intervals()` which, because `hake_recruitment_mcmc` has class
`data.frame`, uses our function `create_intervals.data.frame()` to automatically
calculate intervals for each column (year in this case, and we will exclude the
Virgin sample) of samples.
```{r hake_mcmc2}
res_all_years <- create_intervals(dplyr::select(hake_recruitment_mcmc,
                                                -"Virgin"),
                                  density = FALSE)
```
This gives a list object, with element `res_all[[i]]` corresponding to row `i`
of the data. Each `res_all[[i]]` element is itself a list, giving the same
results as above for a single vector (and also with the `$name`
element corresponding the column of the input, a year in this example). So the
2021 results from above are:
```{r hake_mcmc3}
res_all_years$res_all[[56]]
```

For convenience, the intervals for all years are saved in a single tibble:
```{r hake_mcmc4}
res_all_years$intervals_all
```
The first column is called `quantity` for generalisability so the code can be
applied to different types of data; in this example it represents the years

To see the main values of interest, namely the ETIs and HDIs and the difference
between their widths:
```{r hake_mcmc5}
summary_table(res_all_years)
```

The sum of the differences over all years between the width of the ETI and width
of the HDI, but excluding 2023 and 2024 as these are not informed by data, is
```{r hake_mcmc6}
res_all_years$intervals_all %>%
  dplyr::filter(!quantity %in% c(2023, 2024)) %>%
  dplyr::pull(width_diff) %>%
  sum()
```
which is the source of the ``>30 billion fish`` statement reported in the main text.

To plot the time series shown in Fig. 2A, we have a custom plotting function
`plot.intervals_density_list()`, that gets called because `res_all_years` is
defined to have class `intervals_density_list`, so we can just use:
```{r hake_mcmc7}
plot(res_all_years,
     xlab = "Year",
     ylab = "Recruitment (billions of fish)")
```

<!-- The ETIs match those shown in Table 24 of the 2024 hake assessment (values
manually checked, code is below but not run or printed in vignette): -->
```{r hake_mcmc8, eval = FALSE, echo = FALSE}
res_all_years$intervals_all %>%
  dplyr::select(eti_lower, eti_upper) %>%
  a() %>%
  round(3) * 1000
```


TODO move to long version:

To plot all density plots and ETIs (might not be evaluated when editing as take a long time):
```{r hake_mcmc9, fig.height = 360, eval = FALSE}
plot(res_all_years,
     type = "eti",
     xlim = c(0, 40),
     xlab = "Recruitment (billions of fish)",
     mfrow = c(60, 1))  # 59 default
```

TODO move to long version:

To plot all density plots and HDis (might not be evaluated when editing as take a long time):
```{r hake_mcmc9hdi, fig.height = 360, eval = FALSE}
plot(res_all_years,
     type = "hdi",
     xlim = c(0, 40),
     xlab = "Recruitment (billions of fish)",
     mfrow = c(60, 1))  # 59 default
```

## MCMC samples for multiple years -- relative spawning biomass for Figure 2B

We now use the same approach for the relative spawning biomass calculations
shown in Figure 2B.

The female spawning biomass is the estimated total biomass of all females in the
population that are mature (for context, roughly half of age-2 females are considered
mature). The relative spawning biomass is the females spawning biomass divided
by that for the unfished equilibrium state (the calculation is already done for
each MCMC sample and then the ratios saved).

The values are saved in the package
as a tibble `hake_relative_biomass_mcmc` with years as column headings, and also
includes forecasts made assuming constant catches in 2024, 2025,
and 2026 of 350,000 t, which is close to the average coastwide catch from 2014-2023.
Values correspond to the relative spawning biomass at the start of the
corresponding year (before any fishing).

We can use similar code to above (since the values are in a tibble):
```{r allyears}
res_all_years_2 <- create_intervals(hake_relative_biomass_mcmc,
                                    density = FALSE)
res_all_years_2$intervals_all

res_all_years_2$intervals_all %>% tail()
```

<!-- To confirm that the ETIs match those in Table b of the 2024 hake assessment -->
<!-- (which does not have 2025 onwards); keeping the code for reference -->

```{r allyearsmatch, echo = FALSE, eval = FALSE}
res_all_years_2$intervals_all %>%
  filter(quantity >= 2015) %>%
  mutate(`Year` = quantity,
         `Rel. SB 2.5th percentile` = eti_lower * 100,
         `Rel. SB median` = median * 100,
         `Rel. SB 97.5th percentile` = eti_upper * 100) %>%
  select(`Year`:`Rel. SB 97.5th percentile`) %>%
  filter(`Year` <= 2024) %>%
  knitr::kable(digits = 1)
```

To create Figure 2B, which includes the forecasts:
```{r biomassseries}
plot(res_all_years_2,
     xlim = c(2010, 2027),
     ylim = c(0, 2.6),
     add_line_at_0.4 = TRUE,
     inc = 0.05,
     leg_loc = "topleft",
     xlab = "Year",
     ylab = "Relative spawning biomass")
```

Whether the relative spawning biomass is above or below the management reference point
of 0.4 is key in forming stakeholders' perception of the health of the hake
stock. As seen in the figure, in 2024 and 2025 the ETI does not dip below 0.4 but
the HDI does. Thus, the perception of current and future stock status can depend upon the
definition of credible intervals (ETI versus HDI). The specific years across the
whole time series for which this happens are:

```{r whichyears}
dplyr::filter(res_all_years_2$intervals_all,
              eti_lower > 0.4,
              hdi_lower < 0.4)
```

Also, on the plot the years 2016 and 2020 look like they are also exhibiting this
behaviour, but in fact the HDI is very slightly above 0.4:
```{r whichyearsclose}
dplyr::filter(res_all_years_2$intervals_all,
              quantity %in% c(2016, 2020))
```

To see all the values of interest:
```{r summarytab2}
summary_table(res_all_years_2)
```

To plot results for a single year, for example 2024, extract the results
from the list and use our plotting function, and tailor the figure as necessary
by setting the arguments (see `?plot.intervals_density`):
```{r plotoneyear, fig.height = 12}
index_for_2024 <- which(res_all_years_2$intervals_all$quantity == 2024)
par(mfrow = c(2,1))
plot(res_all_years_2[["res_all"]][[index_for_2024]],
     type = "eti",
     xlim = c(0, 3.5),
     ylim = c(0, 1.1),
     interval_arrows = TRUE,
     xlab = "Relative spawning biomass in 2024",
     y_arrow = 1.07,
     arrowhead_gap = 0.01,
     x_minor_ticks_by = 0.25,
     y_minor_ticks_by = 0.05)

plot(res_all_years_2[["res_all"]][[index_for_2024]],
     type = "hdi",
     xlim = c(0, 3.5),
     ylim = c(0, 1.1),
     interval_arrows = TRUE,
     xlab = "Relative spawning biomass in 2024",
     y_arrow = 1.07,
     arrowhead_gap = 0.01,
     x_minor_ticks_by = 0.25,
     y_minor_ticks_by = 0.05)
```


## Absolute female spawning biomass

The above was for relative female spawning biomass. We now briefly look at
absolute female spawning biomass, in units of millions of tonnes. This is also
saved as a data object in the package (`hake_spawning_biomass_mcmc`). We focus
on the values
for 2023 and 2024 which are given prominence in a bullet in the one-page summary of the hake assessment:

"The median estimate of female spawning biomass at the start of 2024 is 1,884,950 t
(with 95% credible interval from 853,207 to 4,828,382 t). This is an upward shift
from this assessment’s estimate for the 2023 female spawning biomass of 1,335,485 t
(with 95% credible interval from 652,495 to 3,224,819 t)."

So those credible intervals are ETIs. How would HDIs compare? The results are
(in millions of tonnes):
```{r sb1}
res_all_years_spawning <-
  create_intervals(dplyr::select(hake_spawning_biomass_mcmc,
                                 `2023`,
                                 `2024`),
                   density = FALSE)
summary_table(res_all_years_spawning)
```
The above quote, using HDIs instead of ETIs, becomes:

"The median estimate of female spawning biomass at the start of 2024 is 1,884,950 t
(with 95% credible interval from
`r f(dplyr::filter(res_all_years_spawning$intervals_all, quantity ==
                                                       2024)$hdi_lower * 1e06)` to
`r f(dplyr::filter(res_all_years_spawning$intervals_all, quantity ==
                                                       2024)$hdi_upper * 1e06)` t).
This is an upward shift
from this assessment’s estimate for the 2023 female spawning biomass of 1,335,485 t
(with 95% credible interval from
`r f(dplyr::filter(res_all_years_spawning$intervals_all, quantity ==
                                                       2023)$hdi_lower * 1e06)` to
`r f(dplyr::filter(res_all_years_spawning$intervals_all, quantity ==
                                                       2023)$hdi_upper * 1e06)` t)."

The reduction in uncertainty for 2024 from switching from the ETI to the HDI is
`r f(dplyr::filter(res_all_years_spawning$intervals_all, quantity ==
                                                       2024)$width_diff * 1e06)` t.
This is larger than the average catch from 2014-2023 of 338,606 t, of which less
than half would be considered as spawning biomass (mature females; catch is
males plus females). Thus, the reduction in uncertainty is certainly not trivial.
Again, intervals are shifted downwards, implying the stock biomass is lower than implied
when using the original ETIs.

The ETI and HDI plots are
```{r,  sb2, fig.height = 12}
par(mfrow = c(2, 1))
plot(res_all_years_spawning$res_all[[which(res_all_years_spawning$intervals_all$quantity == 2024)]],
     xlim = c(0, 8),
     ylim = c(0, 0.6),
     interval_arrows = TRUE,
     y_arrow = 0.57,
     xlab = "Female spawning biomass in 2024 (millions of tonnes)",
     type = "eti")

plot(res_all_years_spawning$res_all[[which(res_all_years_spawning$intervals_all$quantity == 2024)]],
     xlim = c(0, 8),
     ylim = c(0, 0.6),
     interval_arrows = TRUE,
     y_arrow = 0.57,
     xlab = "Female spawning biomass in 2024 (millions of tonnes)",
     type = "hdi")
```


```{r longchain, echo = FALSE, eval = FALSE}
# Analysis for a longer chain of 32,000 MCMC samples (that took a while to run),
# but since data object is huge, not including it.
# in package.
vec_long <- dplyr::pull(hake_recruitment_mcmc_14_long,
                        "2021")

res_vec_long <- create_intervals(vec_long,
                                  density = FALSE)
summary_table(res_vec_long)
# Results are similar to shorter chain (don't expect to be exactly the same
# anyway due to randomness between chains):
# | Quantity| Value | Interval width |
# | :-------| -----:| -----:|
# | Median  | 10.20 | -- |
# | ETI     | 4.05 -- 29.53 | 25.49 |
# | HDI     | 2.89 -- 25.23 | 22.34 |
# | Range a | 2.27 -- 4.05 | 1.78 |
# | Range b | 16.02 -- 29.53 | 13.52 |

plot(res_vec_long,
     type = "hdi",
     xlim = c(0, 40),
     ylim = c(0, 0.11),
     interval_arrows = TRUE,
     xlab = "Recruitment (billions of age-0 fish)",
     arrowhead_gap = 0.1)
# Density kernel is a bit smoother
```



```{r exit2}
knitr::knit_exit()
```


## TODO

```{r plotttt}
res_2024 <- create_intervals(select(hake_recruitment_mcmc, "2024") %>% pull(),
                             density = FALSE)
plot(res_2024, xlim= c (0, 20))
```

Try changing adjust, changes wiggliness, and allow zero:
```{r adjust}
res_2024_allow_hdi_zero_adjust_0.1 <-
  create_intervals(select(hake_recruitment_mcmc, "2024") %>% pull(), adjust =
                                                                       0.1,
                   allow_hdi_zero = TRUE,
                   density = FALSE)   # NOT SURE HOW THAT INTERACTS WITH
                                      # allow_hdi_zero TODO
plot(res_2024_allow_hdi_zero_adjust_0.1, xlim = c(0, 1))

# Try 0.01:
res_2024_allow_hdi_zero_adjust_0.01 <-
  create_intervals(select(hake_recruitment_mcmc, "2024") %>% pull(), adjust =
                                                                       0.01,
                   allow_hdi_zero = TRUE,
                   density = FALSE)  # See previous TODO
plot(res_2024_allow_hdi_zero_adjust_0.01, xlim = c(0, 1))
plot(res_2024_allow_hdi_zero_adjust_0.01, xlim = c(0, 40))

```
Tweaking adjust (to 0.1 and the above 0.01) does not seem help, and just makes
the distribution really wiggly. Expect it makes the integrals strange - do the
above idea first about always calculating the integral, and the intergral over
the HDI.


# Investigating the issues we came across

## Issue 1 -- trying the default HDInterval options that is not based on density kernel

Explain (see Extended Methods).

TODO maybe redo with `density = TRUE`, since default above now matches this one below.
```{r nodensity}
res_vec_no_density <- create_intervals(vec,
                                        density = FALSE)
res_vec_no_density
res_vec_no_density$intervals %>% a()
```
Our code just uses the `HDInterval::hdi()` method, as confirmed here:
```{r nodensitycheck}
expect_equal(c(res_vec_no_density$intervals$hdi_lower,
               res_vec_no_density$intervals$hdi_upper),
             as.numeric(HDInterval::hdi(vec)))
```


The density was calculated here but only for plotting purposes, and is the same
as above:
```{r nodensity1a}
expect_equal(res_vec_no_density$dens, res_vec$dens)
```

Also there is no `height` value because that was not used when calculating the
HDI.

The equivalent plot to our Fig. 1B for the calculated HDI is
```{r no_densityplot}
plot(res_vec_no_density,
     xlim = c(0,40),
     xlab = "Recruitment (billions of age-0 fish)")
```
But, as can be seen, the heights of the two endpoints of the HDI are not the
same, with the right-hand one being lower.

Furthermore, the integral over the
HDI is only 94.5%, not the theoretical 95%:
```{r nodensity4}
integrate_simpsons(res_vec_no_density$density,
                        domain = c(as.numeric(res_vec_no_density$intervals$hdi_lower),
                                   as.numeric(res_vec_no_density$intervals$hdi_upper)))
```
This is what led us to investigate the other options.

The values of the HDI calculated using density and not using density are
different:
```{r nodensity5}
res_vec$intervals %>% dplyr::select(hdi_lower, hdi_upper)
res_vec_no_density$intervals %>% dplyr::select(hdi_lower, hdi_upper) %>% a()
```

Also try `coda::HPDinterval()`, as recommended in `emdbook::tcredint()` from Ben
Bolker's book.
```{r coda}
res_vec_coda <- coda::HPDinterval(coda::as.mcmc(vec))
res_vec_coda
# Compared to:
res_vec$intervals %>% dplyr::select(hdi_lower, hdi_upper)
```
which are also the same as ours using `HDInterval::hdi()`:
```{r codacheck}
expect_equal(as.numeric(res_vec_coda),
             as.numeric(HDInterval::hdi(vec)))
```

## Issue 2 - default kernel density approach did not quite work

The default of 512 equally spaced points (`n`) at which to compute the kernal density
estimate in the `density()` function, did not yield satisfactory
HDIs. Setting the number of points to 512 here shows this, giving a warning
(from our `create_intervals()` function  that the densities at the HDI lower and
upper values are not within a tolerance of 1% of each other, and the difference
can be seen in the plot:
```{r n512}
res_vec_n_512 <- create_intervals(vec,
                                   n = 512,
                                   density = FALSE)    # TODO this should not be
                                        # relevant now
plot(res_vec_n_512,
     xlim = c(0, 40))
```

We found that increasing `n` to 100,000 gave satisfactory results. Note that
increasing `n` does not increase the wiggliness of the kernel density estimate,
just the number of points at which it is calculated.

However, the integral of the density across this HDI with 512 points was the
correct 95%:
```{r n512integral}
integrate_simpsons(res_vec_n_512$density,
                        domain = c(as.numeric(res_vec_n_512$intervals$hdi_lower),
                                   as.numeric(res_vec_n_512$intervals$hdi_upper)))
```

We also experimented with other `density()` settings, such as `adjust` and `bw`,
but the defaults were satisfactory.

## Issue 3 - zeros TODO

Have to figure out the options to use now, as the defaults changed.

After incorporating Issues 1 and 2,

We found that stil

With no `from` specified, we can get negative lower bounds of the HDI for recruitment:
```{r zeroissue}
res_all_years_from_null <- create_intervals(dplyr::select(hake_recruitment_mcmc,
                                                          -c("Virgin", "1975")),
                                            from = NULL,
                                            allow_hdi_zero = TRUE,
                                            density = FALSE)   # TODO check

# TODO figure out the 1975 error, to do with i_hdi_lower, think I should not
# have the ==
# Testing as get error
#res_all_years_from_null <- create_intervals(dplyr::select(hake_recruitment_mcmc,
#                                                          "1975"),
#                                            from = NULL,
#                                           allow_hdi_zero = TRUE)

res_all_years_from_null$intervals_all
sum(res_all_years_from_null$intervals_all$hdi_lower < 0)
```

Then, setting `from = 0` in `density()` prevents this, yet leads to the lower
bound of the HDI often being 0:

```{r checknonzero}
res_all_years_allow_hdi_zero <- create_intervals(dplyr::select(hake_recruitment_mcmc,
                                                               -"Virgin"),
                                                 allow_hdi_zero = TRUE,
                                                 density = FALSE)  # TODO check

filter(res_all_years_allow_hdi_zero$intervals_all,
       hdi_lower == 0)

years_zero <- filter(res_all_years_allow_hdi_zero$intervals_all,
                     hdi_lower == 0)$quantity

# Check the zero years remaining calculationsa are the same
expect_equal(filter(res_all_years$intervals_all,
                    quantity %in% years_zero) %>%
             select(quantity, median, eti_lower, eti_upper),
             filter(res_all_years_allow_hdi_zero$intervals_all,
                    quantity %in% years_zero) %>%
             select(quantity, median, eti_lower, eti_upper))
```

But


## Investigate warnings regarding split intervals

The function `HDInterval::hdi()` gives a warning "The HDI is discontinuous but
allowSplit = FALSE; the result is a valid CrI but not HDI." The `intervals`
output from `create_intervals()` has a column `warning` that is `TRUE` if this
occurs; for example
```{r warning1}
res_2024$intervals %>% a()
```

This can be investigated using the plotting function, to check that there is
just a small region outside of the HDI that does in fact have a higher density
than some values inside the HDI, which is due to the density approximation being
slightly wiggly. This occurs for `res_2024` calculated above, and setting
`show_discontinuity = TRUE` plots points showing the region in question. These
can barely be seen in the default plot, so we then hone in on the region in
question, seeing that, indeed, it is only a small region and not something to
get overly concerned about.
```{r, warning2, fig.height = 12}
par(mfrow = c(2,1))
plot(res_2024, show_discontinuity = TRUE)

plot(res_2024,
     show_discontinuity = TRUE,
     xlim = c(0, 25),
     ylim = c(0, 0.1))
```

For the recruitments for all years, the following have the warning during the
calculation:
```{r warning3}
years_with_warning <- dplyr::filter(res_all_years$intervals_all,
                                    warning == TRUE)$quantity
years_with_warning
# expect_equal(years_with_warning,
#             c(1975, 2023, 2024))   # Change some of the following if get an error
```

The plots for 1975 and 2023 show similar unconcerning behaviour to that for
2024:
```{r warning4, fig.height = 12}
par(mfrow = c(2, 1))

plot(res_all_years$res_all[[which(res_all_years$intervals_all$quantity == 1975)]],
     show_discontinuity = TRUE)

plot(res_all_years$res_all[[which(res_all_years$intervals_all$quantity == 2023)]],
     show_discontinuity = TRUE,
     xlim = c(0, 25),
     ylim = c(0, 0.1))
```

Note that the 2023 and 2024 recruitments have no data to inform them and so
are essentially samples from the prior distribution used in the assessment.

So we recommend checking the plots to see that any such behaviour is
acceptable. The "HDI is discontinuous ..." warning does not get printed, but if
another warning occurs in the `HDInterval::hdi()` calculation then that will be
shown, along with "New type of warning in create_intervals().", which should be
likely be investigated.




TODO still

NOT changed `density = FALSE` yet.

```{r warn}
res_2024_allow_hdi_zero <- create_intervals(select(hake_recruitment_mcmc, "2024") %>% pull(), allow_hdi_zero = TRUE)

res_2024_allow_hdi_zero$intervals %>% a()

res_2024 <- create_intervals(select(hake_recruitment_mcmc, "2024") %>% pull())

res_2024$intervals %>% a()

res_2024_allow_neg <- create_intervals(select(hake_recruitment_mcmc, "2024") %>%
                                         pull(),
                                       from = -2)

res_2024_allow_neg$intervals %>% a()
# HDI goes -ve, but allowing it to.

plot(res_2024_allow_neg, xlim = c(-2, 20))

# This should give the same, except allow_hdi_zero value. Yes it is, just
# commenting as it gives error for that one change
res_2024_allow_neg_allow_zero <- create_intervals(select(hake_recruitment_mcmc, "2024") %>%
                                                  pull(),
                                                  from = -2,
                                                  allow_hdi_zero = TRUE)

# expect_equal(res_2024_allow_neg$intervals,
#              res_2024_allow_neg_allow_zero$intervals)


# Prob don't need all this. Tidy up.
res_1966 <- create_intervals(select(hake_recruitment_mcmc, "1966") %>% pull())

# Might not have redone all these
expect_equal(min(select(hake_recruitment_mcmc, "2024")),
             as.numeric(res_2024$intervals$"hdi_lower"))
```



This is old and may not be needed any more as defaults changed:

The equivalent table for HDIs would instead be TODO adapt this to show a few
years, highlighting the zero issue
```{r hakemcmc8}
res_all_years$intervals_all %>%
  dplyr::select(hdi_lower, hdi_upper) %>%
  a() %>%
  round(3) * 1000
```

### Examples from HDInterval

Replicating the examples from the help file `?HDInterval::hdi` using our
functions to then easily make plots:
```{r hdinterval}
set.seed(42)
# for a vector:
tst <- rgamma(1e5, 2.5, 2)
HDInterval::hdi(tst)
HDInterval::hdi(tst, credMass=0.8)

# Use our code, and check values agree, and then plot:
res_tst_no_dens <- create_intervals(tst, density = FALSE, credibility = 0.8)
expect_equal(as.numeric(HDInterval::hdi(tst, credMass=0.8)),
             c(res_tst_no_dens$intervals$hdi_lower,
               res_tst_no_dens$intervals$hdi_upper))
plot(res_tst_no_dens)
```

```{r hdinterval2}
# For comparison, the symmetrical 80% CrI:
quantile(tst, c(0.1,0.9))

# for a density:
dens <- density(tst)
HDInterval::hdi(dens, credMass=0.8)
res_tst_dens <- create_intervals(tst, n = 512, credibility = 0.8)  # TODO think
res_tst_dens$intervals %>% a()
# The values don't exactly match because we have from = 0 as the default, and it
# is hard to then specific the default for density.
# expect_equal(as.numeric(hdi(dens, credMass=0.8)),
#              c(res_tst_dens$intervals$hdi_lower,
#                res_tst_dens$intervals$hdi_upper))
plot(res_tst_dens, xlim = c(0,4))
```

With our defaults for `n`, the uneveness is resolved:
```{r, hdinterval4}
res_tst_dens_default_n <- create_intervals(tst, credibility = 0.8) # TODO think
res_tst_dens_default_n$intervals %>% a()
plot(res_tst_dens_default_n, xlim = c(0,4))

```
