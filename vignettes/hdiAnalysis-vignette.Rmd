---
title: "Vignette for hdiAnalysis"
author: "Andrew Edwards"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette for hdiAnalysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
date: "Last rendered on `r format(Sys.time(), '%d %B, %Y')`"
---

<!-- To build either run
rmarkdown::render("hdiAnalysis-vignette.Rmd")
 or click the knit button in RStudio -->


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 6
)
```

We present what works, to be used as a template for other analyses, and then
change some code settings to show what did not work for our investigations.

## Figure 1

```{r setup}
load_all()      # TODO change to library(hdiAnalysis) when done
library(dplyr)
library(spatstat.geom)   # Needed for checking some integrals
library(coda)            # Needed to test alternative code
```

ROUGH for now to remake figures

The hake Markov chain Montel Carlo (MCMC) recruitment and relative biomass
values are saved as data objects in the package, with `rec_2021` being the
vector of 8,000 MCMC values used for our Fig. 1.

```{r rec1}
summary(rec_2021)
length(rec_2021)
res_2021 <- create_intervals(rec_2021)
res_2021
res_2021$intervals %>% a()
```

Check the integral, needs the `spatstat.geom` package to evaluate an integral on
a density object:
```{r rec2}
spatstat.geom::integral(res_2021$density)
spatstat.geom::integral(res_2021$density,
                        domain = c(as.numeric(res_2021$intervals$eti_lower),
                                   as.numeric(res_2021$intervals$eti_upper)))

spatstat.geom::integral(res_2021$density,
                        domain = c(as.numeric(res_2021$intervals$hdi_lower),
                                   as.numeric(res_2021$intervals$hdi_upper)))
```
So the ETI approach is only a 94% interval, so it's actually narrower
than the true 95% ETI interval. This isbecause it has not used the density, which could
be changed to make a more accurate interval. But no-one ever has so we should not
get into. So maybe mention in Extended Methods.

HDI is bang on, which is a good confirmation. TODO do that with other options
that didn't work.

Plotting the resulting density function and intervals is simply done using our
custom plotting functions, with options for automatically adding intervals and lines. The ETI is:
```{r plot}
plot(res_2021,
     type = "eti",
     xlim = c(0, 40),
     ylim = c(0, 0.11),
     interval_arrows = TRUE,
     xlab = "Recruitment (billions of age-0 fish)",
     arrowhead_gap = 0.1)
```
and the HDI is
```{r plot2}
plot(res_2021,
     type = "hdi",
     xlim = c(0, 40),
     ylim = c(0, 0.11),
     interval_arrows = TRUE,
     xlab = "Recruitment (billions of age-0 fish)",
     arrowhead_gap = 0.1)
```
The `res_2021` object has our class `intervals_density`, and our custom plotting
function `plot.intervals_density()` automatically gets used on the object. See
`?plot.intervals_density()` for details and full options. Our complete Figure 1
is reproduced with the command `figure_1()`, which can be adapted by users if
desired for their own data.

## Figure 2

The MCMC samples of hake recruitment for each year are saved in the package as
the tibble `hake_recruitment_mcmc`, with each column corresponding to a year
(with the first column representing the Virgin situation) and each of the 8,000
rows representing an MCMC sample:
```{r hake_mcmc}
hake_recruitment_mcmc
```

To create ETIs and HDIs for estimates of recruitment for each year, simply use
`create_intervals()` which, because `hake_recruitment_mcmc` has class
`data.frame`, uses our function `create_intervals.data.frame()` to automatically
calculate intervals for each column (year in this case, and we will exclude the
Virgin sample) of samples.
```{r hake_mcmc2}
res_all_years <- create_intervals(dplyr::select(hake_recruitment_mcmc,
                                                -"Virgin"))
```
This gives a list object, with `res_all` being a list for which each element corresponds to a year and
gives the same results as above for a single year (and also with the `$name`
element corresponding the column of the input, a year in this example). So the
2021 results from above are:
```{r hake_mcmc3}
res_all_years$res_all[[56]]
```

For convenience, the intervals for all years are saved in a single tibble:
```{r hake_mcmc4}
res_all_years$intervals_all
```

To see the main values of interest, namely the ETIs and HDIs and the difference
between their widths:
```{r hake_mcmc5}
dplyr::select(res_all_years$intervals_all,
              quantity, eti_lower, eti_upper, hdi_lower, hdi_upper, width_diff) %>%
  a()
```

The sum of the differences over all years between the width of the ETI and width
of the HDI, but excluding 2023 and 2024 as these are not informed by data, is
```{r hake_mcmc6}
res_all_years$intervals_all %>%
  dplyr::filter(!quantity %in% c(2023, 2024)) %>%
  dplyr::pull(width_diff) %>%
  sum()
```
which is the source of the ``>25 billion fish`` statement reported in the main text.

To plot Fig. 2A, we have a custom plotting function
`plot.intervals_density_list()`, that gets called because `res_all_years` is
defined to have class `intervals_density_list`, so we can just use:
```{r hake_mcmc7}
plot(res_all_years)
```

The ETIs match those shown in Table 24 of the 2024 hake assessment (values
manually checked, code not run here)
```{r hake_mcmc8, eval = FALSE}
res_all_years$intervals_all %>%
  dplyr::select(eti_lower, eti_upper) %>%
  a() %>%
  round(3) * 1000
```

To plot all density plots:
```{r hake_mcmc9, fig.height = 360}
plot(res_all_years,
     type = "eti",
     xlim = c(0, 40),
     xlab = "Recruitment (billions of fish)",
     mfrow = c(60, 1))  # 59 default
```

TODO dig into warnings, fix zero issue, which might then fix the plotting issue automatically


# Investigating the issues we came across

## Issue 1 -- tying the default HDInterval options that is not based on density kernel

Explain (see Extended Methods).

```{r nodensity}
res_2021_no_density <- create_intervals(rec_2021,
                                     density = FALSE)
res_2021_no_density
res_2021_no_density$intervals %>% a()
```

The density was calculated here but only for plotting purposes, and is the same
as above:
```{r nodensity1a}
expect_equal(res_2021_no_density$dens, res_2021$dens)
```

Also there is no `height` value because that was not used when calculating the
HDI.

The equivalent plot to our Fig. 1B for the calculated HDI is
```{r no_densityplot}
plot(res_2021_no_density,
     xlim = c(0,40),
     xlab = "Recruitment (billions of age-0 fish)")
```
But, as can be seen, the heights of the two endpoints of the HDI are not the
same, with the right-hand one being lower.

Furthermore, the integral over the
HDI is only 94.5%, not the theoretical 95%:
```{r nodensity4}
spatstat.geom::integral(res_2021_no_density$density,
                        domain = c(as.numeric(res_2021_no_density$intervals$hdi_lower),
                                   as.numeric(res_2021_no_density$intervals$hdi_upper)))
```
This is what led us to investigate the other options.

The values of the HDI calculated using density and not using density are
different:
```{r nodensity5}
res_2021$intervals %>% dplyr::select(hdi_lower, hdi_upper)
res_2021_no_density$intervals %>% dplyr::select(hdi_lower, hdi_upper)
```

Also try `coda::HPDinterval()`, as recommended in `emdbook::tcredint()` from Ben
Bolker's book.
```{r coda}
res_2021_coda <- coda::HPDinterval(coda::as.mcmc(rec_2021))
res_2021_coda
# Compared to:
res_2021$intervals %>% dplyr::select(hdi_lower, hdi_upper)
```
Interval from coda is shorter. Check the integral:
```{r codaintegral}
spatstat.geom::integral(res_2021$density,
                        domain = c(as.numeric(res_2021_coda[1, "lower"]),
                                   as.numeric(res_2021_coda[1, "upper"])))
```
Again, not quite 95%.

## Issue 2 - default kernel density approach did not quite work

The default of 512 equally spaced points (`n`) at which to compute the kernal density
estimate in the `density()` function, did not yield satisfactory
HDIs. Setting the number of points to 512 here shows this, giving a warning
(from our `create_intervals()` function  that the densities at the HDI lower and
upper values are not within a tolerance of 1% of each other, and the difference
can be seen in the plot:
```{r n512}
res_2021_n_512 <- create_intervals(rec_2021,
                                   n = 512)
plot(res_2021_n_512,
     xlim = c(0, 40))
```

We found that increasing `n` to 100,000 gave satisfactory results. Note that
increasing `n` does not increase the wiggliness of the kernel density estimate,
just the number of points at which it is calculated.

However, the integral of the density across this HDI with 512 points was the
correct 95%:
```{r n512integral}
spatstat.geom::integral(res_2021_n_512$density,
                        domain = c(as.numeric(res_2021_n_512$intervals$hdi_lower),
                                   as.numeric(res_2021_n_512$intervals$hdi_upper)))
```

We also experimented with other `density()` settings, such as `adjust` and `bw`,
but the defaults were satisfactory.

## Issue 3 - zeros TODO


TODO The equivalent table for HDIs would instead be TODO adapt this to show a few
years, highlighting the zero issue
```{r hakemcmc8}
res_all_years$intervals_all %>%
  dplyr::select(hdi_lower, hdi_upper) %>%
  a() %>%
  round(3) * 1000
```


## Quick long chain, but easiest to just re-run vignette with long chain results used instead

Somewhere, check the longer chain, not sure if including in package (could do if
needed, or just save these calculations somewhere else and state we did them -
would really be redoing the vignette with longer chain. Do quick calcs here
while writing appendix
```{r longchain}
rec_2021_long <- dplyr::pull(hake_recruitment_mcmc_14_long,
                             "2021")

res_2021_long <- create_intervals(rec_2021_long)

res_2021_long_no_density <- create_intervals(rec_2021_long,
                                             density = FALSE)

res_2021_long$intervals %>% a()
res_2021_long_no_density$intervals %>% a()
# NOTE values change anyway, including median, so gets hard to compare with
# original

plot(res_2021_long)

# Using density with long MCMC
spatstat.geom::integral(res_2021_long$density,
                        domain = c(as.numeric(res_2021_long$intervals$hdi_lower),
                                   as.numeric(res_2021_long$intervals$hdi_upper)))

# Not using density with long MCMC
spatstat.geom::integral(res_2021_long_no_density$density,
                        domain = c(as.numeric(res_2021_long_no_density$intervals$hdi_lower),
                                   as.numeric(res_2021_long_no_density$intervals$hdi_upper)))
```
